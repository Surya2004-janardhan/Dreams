name: NodeJS - Scheduled Workflows

# Scheduled automation for content creation workflows
# - workflow/auto: Runs at 8:00 AM/PM IST (2:30 AM/PM UTC) - Full video creation with FFmpeg
# - posts-workflow: Runs at 7:30 AM/PM IST (2:00 AM/PM UTC) - Social media posting only
# - 18-minute timeout protects against infinite hangs
# - Proper cleanup ensures resources are freed

on:
  schedule:
    # workflow/auto timings (8:00 AM & 8:00 PM IST ‚Üí 2:30 AM & 2:30 PM UTC)
    - cron: "30 2 * * *"
    - cron: "30 14 * * *"
    # workflow/posts-workflow timings (7:30 AM & 7:30 PM IST ‚Üí 2:00 AM & 2:00 PM UTC)
    - cron: "0 2 * * *"
    - cron: "0 14 * * *"
  workflow_dispatch:

jobs:
  run-workflows:
    runs-on: ubuntu-latest
    timeout-minutes: 18
    steps:
      - uses: actions/checkout@v4
        with:
          lfs: true

      - name: Pull Git LFS files
        run: git lfs pull

      - name: Verify video files
        run: |
          if [ -f "videos/Base-vedio.mp4" ]; then
            FILE_SIZE=$(stat -c%s "videos/Base-vedio.mp4")
            if [ "$FILE_SIZE" -gt 1000000 ]; then
              echo "‚úÖ Video file exists and has valid size: $FILE_SIZE bytes"
            else
              echo "‚ùå Video file exists but is too small: $FILE_SIZE bytes"
              exit 1
            fi
          else
            echo "‚ùå Video file not found: videos/Base-vedio.mp4"
            exit 1
          fi

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18

      - name: Install dependencies
        run: npm install

      - name: Install FFmpeg (for auto workflow only)
        if: github.event.schedule == '30 2 * * *' || github.event.schedule == '30 14 * * *'
        run: sudo apt-get update && sudo apt-get install -y ffmpeg

      - name: Run server and trigger endpoints
        run: |
          # Function to cleanup server
          cleanup_server() {
            if [ ! -z "$SERVER_PID" ] && kill -0 $SERVER_PID 2>/dev/null; then
              echo "Cleaning up server (PID: $SERVER_PID)"
              kill $SERVER_PID 2>/dev/null || true
              wait $SERVER_PID 2>/dev/null || true
            fi
          }

          # Set trap to cleanup on exit
          trap cleanup_server EXIT

          node server.js &
          SERVER_PID=$!
          echo "Server started with PID $SERVER_PID"
          sleep 5

          # Trigger auto workflow at scheduled times (requires FFmpeg)
          if [[ "${{ github.event.schedule }}" == "30 2 * * *" ]] || [[ "${{ github.event.schedule }}" == "30 14 * * *" ]]; then
            echo "Triggering /workflow/auto (with FFmpeg)"
            RESPONSE=$(curl -s --max-time 30 -X POST http://localhost:${PORT:-3000}/workflow/auto)
            CURL_EXIT_CODE=$?
            
            if [ $CURL_EXIT_CODE -eq 0 ]; then
              echo "‚úÖ Workflow/auto triggered successfully"
              TASK_ID=$(echo "$RESPONSE" | jq -r '.taskId // empty' 2>/dev/null)
              if [ -n "$TASK_ID" ] && [ "$TASK_ID" != "null" ] && [ "$TASK_ID" != "empty" ]; then
                echo "üìã Task ID: $TASK_ID"
              else
                echo "‚ö†Ô∏è No task ID returned, but proceeding with monitoring"
              fi
            else
              echo "‚ùå Workflow/auto trigger failed (exit code: $CURL_EXIT_CODE)"
              echo "Response: $RESPONSE"
              echo "Continuing with monitoring anyway..."
            fi
            
            # Simple polling: wait at least 15 minutes, check status every 30 seconds
            echo "Monitoring workflow for at least 15 minutes..."
            UNKNOWN_COUNT=0
            
            for i in {1..30}; do
              sleep 30
              # Try to get status with multiple fallback methods
              STATUS_RESPONSE=$(curl -s --max-time 10 http://localhost:${PORT:-3000}/workflow/status 2>/dev/null)
              
              if [ $? -eq 0 ] && [ -n "$STATUS_RESPONSE" ]; then
                # Try jq first
                STATUS=$(echo "$STATUS_RESPONSE" | jq -r '.status' 2>/dev/null)
                if [ $? -ne 0 ] || [ -z "$STATUS" ] || [ "$STATUS" = "null" ]; then
                  # Fallback: try grep for status
                  STATUS=$(echo "$STATUS_RESPONSE" | grep -o '"status":"[^"]*"' | cut -d'"' -f4 2>/dev/null)
                  if [ -z "$STATUS" ]; then
                    STATUS="unknown"
                  fi
                fi
              else
                STATUS="unknown"
              fi
              
              echo "Status check $i/30: $STATUS"
              
              # Track consecutive unknown statuses
              if [[ "$STATUS" == "unknown" ]]; then
                UNKNOWN_COUNT=$((UNKNOWN_COUNT + 1))
              else
                UNKNOWN_COUNT=0
              fi
              
              # Break if workflow clearly completed or failed
              if [[ "$STATUS" == "completed" ]] || [[ "$STATUS" == "failed" ]] || [[ "$STATUS" == "partial_success" ]]; then
                echo "Workflow finished with status: $STATUS"
                break
              fi
              
              # If server is down or status is unknown for 3+ consecutive checks, assume completion
              if [[ $UNKNOWN_COUNT -ge 3 ]]; then
                echo "Server not responding consistently (3+ unknown statuses), assuming workflow completed"
                break
              fi
            done
            echo "Workflow monitoring complete"
          fi

          # Trigger posts workflow at scheduled times (no FFmpeg needed)
          if [[ "${{ github.event.schedule }}" == "0 2 * * *" ]] || [[ "${{ github.event.schedule }}" == "0 14 * * *" ]]; then
            echo "Pinging slide microservice..."
            SLIDE_RESPONSE=$(curl -s --max-time 30 -X GET https://slide-microservice.onrender.com)
            if [ $? -eq 0 ]; then
              echo "‚úÖ Slide microservice ping successful"
            else
              echo "‚ö†Ô∏è Slide microservice ping failed, proceeding anyway"
            fi
            
            echo "Waiting 50 seconds for microservice to be ready..."
            sleep 50
            
            echo "Triggering /posts-workflow (no FFmpeg needed)"
            POSTS_RESPONSE=$(curl -s --max-time 30 -X POST http://localhost:${PORT:-3000}/posts-workflow)
            POSTS_EXIT_CODE=$?
            
            if [ $POSTS_EXIT_CODE -eq 0 ]; then
              echo "‚úÖ Posts workflow triggered successfully"
              echo "Response: $POSTS_RESPONSE"
            else
              echo "‚ùå Posts workflow trigger failed (exit code: $POSTS_EXIT_CODE)"
              echo "Response: $POSTS_RESPONSE"
            fi
          fi

          # Server will be cleaned up automatically by trap
        env:
          PORT: ${{ secrets.PORT }}
          GOOGLE_CREDENTIALS: ${{ secrets.GOOGLE_CREDENTIALS }}
          GOOGLE_SHEET_ID: ${{ secrets.GOOGLE_SHEET_ID }}
          POSTS_SHEET_ID: ${{ secrets.POSTS_SHEET_ID }}
          YOUTUBE_REFRESH_TOKEN: ${{ secrets.YOUTUBE_REFRESH_TOKEN }}
          OAUTH_ACCESS_TOKEN: ${{ secrets.OAUTH_ACCESS_TOKEN }}
          ASSEMBLYAI_API_KEY: ${{ secrets.ASSEMBLYAI_API_KEY }}
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          GEMINI_API_KEY_FOR_IMAGES_1: ${{ secrets.GEMINI_API_KEY_FOR_IMAGES_1 }}
          GEMINI_API_KEY_FOR_IMAGES_2: ${{ secrets.GEMINI_API_KEY_FOR_IMAGES_2 }}
          GEMINI_API_KEY_FOR_AUDIO: ${{ secrets.GEMINI_API_KEY_FOR_AUDIO }}
          INSTAGRAM_ACCOUNT_ID: ${{ secrets.INSTAGRAM_ACCOUNT_ID }}
          INSTAGRAM_ACCESS_TOKEN: ${{ secrets.INSTAGRAM_ACCESS_TOKEN }}
          FACEBOOK_ACCESS_TOKEN: ${{ secrets.FACEBOOK_ACCESS_TOKEN }}
          FACEBOOK_PAGE_ID: ${{ secrets.FACEBOOK_PAGE_ID }}
          EMAIL_USER: ${{ secrets.EMAIL_USER }}
          EMAIL_APP_PASSWORD: ${{ secrets.EMAIL_APP_PASSWORD }}
          NOTIFICATION_EMAIL: ${{ secrets.NOTIFICATION_EMAIL }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          SUPABASE_BUCKET: ${{ secrets.SUPABASE_BUCKET }}
          GEMINI_API_KEY_FOR_T2T: ${{ secrets.GEMINI_API_KEY_FOR_T2T }}
